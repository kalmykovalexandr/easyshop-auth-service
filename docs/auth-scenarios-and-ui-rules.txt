Auth flows & UI rules (consolidated)

General rules
- Server responses for invalid credentials are always generic; no reason is revealed.
- All UI strings come from `messages.properties` (e.g. `login.errors.*`).
- Sign-in errors disappear only after the user edits the e-mail or password fields.
- External clients (Postman, mobile, etc.) must receive the same status codes and payloads as our UI.
- Successful POST `/api/auth/register` and POST `/api/auth/send-code` include a `Retry-After` header (seconds until the next resend); the UI arms the “Send again” timer with that value.

Sign in — scenarios
1) Successful sign-in (`enabled = true`)
- Action: valid e-mail + password → Sign in.
- UI: redirect to the protected route, no `error` query parameter.
- Backend: standard Spring Security login via `DaoAuthenticationProvider` (302 → target).

2) Invalid credentials
- Action: wrong e-mail and/or password.
- UI: banner “Invalid e-mail or password. Try again.”; persists until the field changes.
- Backend: 302 → `/login?error=credentials` (same for any bad combination, including form posts).

3) Account not verified (`enabled = false`)
- Action: user tries to sign in before confirming e-mail.
- UI: redirect to `/login?error=disabled`, OTP modal opens with the stored e-mail.
- Ensure: frontend fires POST `/api/auth/send-code` once (fire-and-forget) to make sure a code exists.
- Confirm: “Confirm” → POST `/api/auth/verify-code`; “Send again” → POST `/api/auth/send-code` (cooldown enforced).
- Success: after verification the `error` parameter is removed from the URL and the banner hides.

4) Client-side validation (before hitting backend)
- Empty fields (one or both): “Fill all fields.” with focus on the first empty control.
- Invalid e-mail format: “Enter a valid e-mail address.” and focus on the e-mail input.
- Only a valid pair of e-mail/password submits the form to the server.

Password “eye” toggle rule
- Show the toggle only when the password input is focused and non-empty.
- Hide the toggle when the field is empty or loses focus.
- Apply the same behaviour to Sign in, Register, Forgot/Reset views.

Registration scenarios

1. Fresh registration (success)
- User enters valid e-mail, strong password, confirmation.
- Frontend sends POST `/api/auth/register`.
- Backend creates user with `enabled=false`, generates OTP, sends e-mail, and returns `Retry-After`.
- UI opens the OTP modal, disables “Send again”, and starts the countdown using `Retry-After`.
- User submits the code; POST `/api/auth/verify-code` with `activateUser=true` returns `204`, account becomes active.

2. Repeat registration for an unverified user
- E-mail already exists but `enabled=false`.
- Backend updates the password and calls `generateOtp(email, true)`.
- Active code from Redis is re-sent immediately; only `cooldownUntil` is refreshed (OTP expiry stays the same).
- UI receives `Retry-After`, restarts the timer, and user gets the same code in a fresh e-mail.

3. Registration with a verified e-mail
- Condition: user exists with `enabled=true`.
- Result: `BusinessException(EMAIL_ALREADY_USED)` → 409/422 response.
- UI shows “Email is already registered”.

4. Registration with invalid form data
- Issues: invalid e-mail, weak password, mismatched passwords.
- Bean Validation (`AuthDto`) raises 400 with field errors (`EMAIL_INVALID`, `PASSWORD_WEAK`, `PASSWORDS_DO_NOT_MATCH`).
- UI highlights fields and stops before OTP generation.

5. Resend OTP before cooldown expires
- User presses “Send again” while `cooldownUntil > now`.
- POST `/api/auth/send-code` throws `RateLimitExceededException` → 429 with `Retry-After`.
- UI shows “Please wait {0} seconds…” and keeps the button disabled until the timer finishes.

6. Resend OTP after cooldown (OTP still valid)
- Cooldown finished, OTP not expired.
- Backend re-sends the same code, refreshes `cooldownUntil`, returns 202 + `Retry-After`.
- UI shows “We sent a new verification code.” and restarts the timer with the returned value.

7. Resend after OTP expiry
- `otpExpiresAt < now` when the user presses “Send again”.
- Backend generates a new code, saves state, sends e-mail, returns 202 + `Retry-After`.
- Old code becomes invalid; UI message remains the same but the modal now expects the new code.

8. Wrong OTP during confirmation
- User submits an incorrect code.
- `/api/auth/verify-code` responds 400 with `VERIFICATION_CODE_INVALID`, increments attempts.
- UI shows “Verification failed. Try again.”

9. OTP expired during confirmation
- User submits the code after `otpExpiresAt`.
- Backend clears state and replies 410 `VERIFICATION_CODE_EXPIRED`.
- UI prompts user to request a new code and re-enables “Send again”.

10. Too many OTP attempts
- User exceeds `verification-max-attempts` with wrong codes.
- State is cleared; backend returns 400 `TOO_MANY_VERIFICATION_ATTEMPTS`.
- UI shows a warning and prompts to resend a code.

11. Confirmation without an active OTP
- Redis entry is absent (cleanup job, TTL expired, code never requested).
- `/api/auth/verify-code` returns 404 `VERIFICATION_CODE_NOT_FOUND`.
- UI shows “Request a new verification code” and focuses on resend.
