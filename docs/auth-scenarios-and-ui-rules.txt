Auth flows и UI‑правила (консолидировано)

Общие правила
- Ответы сервера на неверные учётные данные всегда generic, без раскрытия причины.
- UI‑сообщения берутся из messages.properties (login.errors.* и др.).
- Ошибки на Sign in очищаются только при правке e‑mail или пароля пользователем.

Sign in — сценарии
1) Успешный вход (enabled=true)
- Действия: валидные e‑mail + пароль → Sign in.
- Ожидание (UI): редирект на защищённый маршрут, без параметра error.
- Ожидание (Backend): 302/успешная аутентификация через DaoAuthenticationProvider.

2) Неверные данные (неверный e‑mail или пароль)
- Действия: неверные e‑mail/пароль → Sign in.
- Ожидание (UI): баннер «Invalid e‑mail or password. Try again.»; не исчезает сам, только при вводе в e‑mail/пароль.
- Ожидание (Backend): 302 → /login?error=credentials (одинаково для любых неверных комбинаций; так же из Postman/form POST).

3) Аккаунт не подтверждён (disabled)
- Действия: попытка входа неактивного пользователя.
- Ожидание (UI): /login?error=disabled, автопоказ модалки OTP с корректным e‑mail.
- Ensure: фронт один раз вызывает POST /api/auth/ensure-verification-code (fire‑and‑forget).
- Подтверждение: «Confirm» → POST /api/auth/verify-code; «Send again» → POST /api/auth/send-code (учитывает cooldown).
- После успешной верификации параметр error удаляется из URL, баннер скрывается.

4) Клиентская валидация формы Sign in (до запроса на сервер)
- Пустые поля (одно/оба): баннер «Fill all fields.»; фокус в первое незаполненное поле.
- Неверный формат e‑mail: «Enter a valid e‑mail address.»; фокус в e‑mail.
- Только при валидных e‑mail и пароле форма отправляется на сервер.

Правило для «глазка» (переключатель видимости пароля)
- Показать кнопку только когда поле пароля в фокусе И в нём есть непустое значение.
- Скрыть кнопку, если поле пустое или потеряло фокус.
- Применяется ко всем полям пароля в сервисе (Sign in, Forgot/Reset и т.п.).

Сценарии регистрации

1) Успешная регистрация (включая повторную)
- Ввожу корректный формат и несуществующий e‑mail, корректный пароль и его подтверждение.
- Вызываю /api/auth/register на backend.
- Бэкенд проверяет, существует ли уже пользователь с таким e‑mail.
- Если пользователь существует, но ещё не подтверждён (повторная регистрация):
  - Генерируем и отправляем OTP-код на почту только если в Redis нет активного кода (предыдущий истёк/удалён).
  - Если активный OTP-код есть в Redis, новый код не отправляем (no-op).
- На фронтенде в модальном окне ввода OTP всегда показывается одно и то же сообщение «Проверьте почту», независимо от того, отправили новый код или нет.
- Аккаунт создаётся успешно.

2) Успешная регистрация с повторной отправкой otp кода
- Ввожу корректный формат и несуществующий e‑mail, корректный пароль и его подтверждение.
- Вызываю /api/auth/register на backend.
- Бэкенд проверяет, существует ли уже пользователь с таким e‑mail.
- Пользователь запрашивает повторный otp code и вызывает send-code

- Если пользователь существует, но ещё не подтверждён (повторная регистрация):
  - Генерируем и отправляем OTP-код на почту только если в Redis нет активного кода (предыдущий истёк/удалён).
  - Если активный OTP-код есть в Redis, новый код не отправляем (no-op).
- На фронтенде в модальном окне ввода OTP всегда показывается одно и то же сообщение «Проверьте почту», независимо от того, отправили новый код или нет.
- Аккаунт создаётся успешно.
