Auth flows & UI rules (consolidated)

General rules
- Server responses for invalid credentials stay generic; we never disclose which field was wrong.
- All UI strings come from `messages.properties` (for example `login.errors.*`).
- Sign-in error banners clear only after the user edits the e-mail or password input.
- External clients (Postman, mobile, etc.) must receive the same HTTP status codes and payloads as the web UI.
- Successful POST `/api/auth/register` and POST `/api/auth/send-code` respond with JSON `{ cooldownSeconds, cooldownUntil, otpStatus }`; the UI reads the returned cooldown values to drive the "Send again" timer.
- Any web form with required e-mail/password/confirm-password fields (sign-in, registration, forgot-password) shows "Fill all fields." when one or more fields are empty. The message disappears when the user focuses the missing input.
- Visible error banners auto-dismiss ~7 seconds after they appear and also disappear immediately when the user focuses any field or switches between sign-in / registration screens.

Sign in — scenarios
1) Successful sign-in (enabled user)
- Action: user submits valid credentials via the form or direct POST `/login`.
- Backend: Spring Security authenticates, issues 302 to the success URL (`/` by default), session established.
- UI: browser follows the redirect; there is no `error` parameter in the URL.

2) Invalid credentials or locked account
- Action: e-mail not found, wrong password, or `accountNonLocked=false`.
- Backend: redirects to `/login?error=credentials`, persists the last attempted username in the session.
- UI: banner “Invalid e-mail or password. Try again.” appears; it stays until the user edits the e-mail or password field.
- External clients receive the same redirect/response body as the browser (generic message only).

3) Account not verified (`enabled=false`)
- Action: user submits correct credentials for an unverified account.
- Backend: failure handler routes to `/login?error=disabled`, storing the username for reuse.
- UI: OTP modal opens automatically with the stored e-mail. The �Send again� button is disabled right away using the configured default cooldown, and once the POST `/api/auth/send-code` response returns with the cooldown payload, the timer syncs to that value. After successful OTP confirmation (`POST /api/auth/verify-code` with `activateUser=true` → 204), the modal closes, the success modal appears, and the user can sign in normally.
- Resend, cooldown, and invalid-OTP behaviour during this flow equal the registration scenarios 6–12.

4) Client-side validation and empty fields
- Empty e-mail, empty password, or both: submit is blocked with “Fill all fields.” and focus moves to the first missing input.
- Invalid e-mail format: submit is blocked with “Enter a valid e-mail address.” and focus returns to the e-mail field.
- Only when all checks pass does the form submit to `/login`.
- Direct POST `/login` with missing fields (Postman, etc.) receives the same backend response as the UI would after validation (`/login?error=credentials`).

5) Remember last username
- After any failed sign-in the backend stores `SPRING_SECURITY_LAST_USERNAME`; `LoginController` injects it into the login template so the UI pre-fills the e-mail field on the next visit.
- Clearing inputs or succeeding later does not automatically blank the field; the user must overwrite it manually.

6) Sign-in with unverified registration (pending OTP)
- Prerequisite: user completed registration but has not verified the e-mail (`enabled=false`).
- Action: user submits correct e-mail/password via `/login`.
- Backend: authentication fails with `DisabledException`; failure handler redirects to `/login?error=disabled` and stores the username.
- UI: on page load detects `error=disabled`, opens the OTP modal with the stored e-mail, sends `/api/auth/send-code` (respects cooldown payload), and guides the user through code verification. After successful `POST /api/auth/verify-code` (`activateUser=true`), account becomes active and subsequent sign-in succeeds.
- If the password is incorrect, the backend responds with the generic credentials error instead of opening the OTP modal.

Registration scenarios

1. Fresh registration (success)
- User enters valid e-mail, strong password, and confirmation; frontend sends POST `/api/auth/register`.
- Backend creates user with `enabled=false`, generates OTP, sends e-mail, returns 202 with the cooldown payload.
- UI opens the OTP modal, disables “Send again”, and starts the countdown using `cooldownSeconds`.
- User submits the code; POST `/api/auth/verify-code` with `activateUser=true` returns 204 and the account becomes active.

2. Repeat registration for an unverified user
- E-mail already exists but `enabled=false`.
- Backend updates the password and calls `generateOtp(email, true)`.
- Active code from Redis is re-sent immediately; only `cooldownUntil` is refreshed (OTP expiry stays the same). Response still contains the cooldown payload.
- UI restarts the resend timer; the user receives the same code in a fresh e-mail.

3. Registration with a verified e-mail
- Condition: user exists with `enabled=true`.
- Result: `BusinessException(EMAIL_ALREADY_USED)` → 409/422 response.
- UI shows “Email is already registered”.

4. Registration with empty fields
- Cases: empty e-mail, empty password, empty confirmPassword, or all empty.
- UI (client validation): shows “Fill all fields.”, focusing the first missing input; the request is blocked.
- External clients (Postman) receive 400 with `EMAIL_REQUIRED`, `PASSWORD_REQUIRED`, etc., plus the generic top-level message.

5. Registration with invalid form data
- Issues: invalid e-mail format, weak password, passwords do not match.
- Bean Validation returns 400 with field errors (`EMAIL_INVALID`, `PASSWORD_WEAK`, `PASSWORDS_DO_NOT_MATCH`).
- UI highlights fields and does not proceed to OTP generation.

6. Resend OTP before cooldown expires
- User presses “Send again” while `cooldownUntil > now`.
- POST `/api/auth/send-code` throws `RateLimitExceededException` → 429 with the cooldown payload.
- UI shows “Please wait {0} seconds...” and keeps the button disabled until the timer completes.

7. Resend OTP after cooldown (OTP still valid)
- Cooldown finished, OTP not expired.
- Backend re-sends the same code, refreshes `cooldownUntil`, returns 202 with the cooldown payload.
- UI молча перезапускает таймер по новым значениям; дополнительных уведомлений не показываем.

8. Resend after OTP expiry
- `otpExpiresAt < now` when the user presses “Send again”.
- Backend generates a new code, persists it, sends e-mail, returns 202 with the cooldown payload.
- Old code becomes invalid; the modal message remains generic but expects the new code.

9. Wrong OTP during confirmation
- User submits an incorrect code.
- `/api/auth/verify-code` responds 400 with `VERIFICATION_CODE_INVALID`, incrementing the attempt counter.
- UI shows “Verification failed. Try again.”

10. OTP expired during confirmation
- User submits the code after `otpExpiresAt`.
- Backend clears state and returns 410 `VERIFICATION_CODE_EXPIRED`.
- UI prompts the user to request a new code and re-enables “Send again”.

11. Too many OTP attempts
- User exceeds `verification-max-attempts` with wrong codes.
- State is cleared; backend responds 400 `TOO_MANY_VERIFICATION_ATTEMPTS`.
- UI displays a warning and offers the resend option.

12. Confirmation without an active OTP
- Redis entry is absent (cleanup job, TTL expired, or code never generated).
- `/api/auth/verify-code` returns 404 `VERIFICATION_CODE_NOT_FOUND`.
- UI shows “Request a new verification code” and focuses on resend.







